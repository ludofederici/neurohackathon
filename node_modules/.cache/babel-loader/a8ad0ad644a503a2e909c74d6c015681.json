{"ast":null,"code":"import invariant from \"invariant\";\n\n////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n  var _uri$split = uri.split(\"?\"),\n    uriPathname = _uri$split[0];\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n      var dynamicMatch = paramRe.exec(routeSegment);\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n  return match || default_ || null;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\nvar match = function match(path, uri) {\n  return pick([{\n    path: path\n  }], uri);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n  var _to$split = to.split(\"?\"),\n    toPathname = _to$split[0],\n    toQuery = _to$split[1];\n  var _base$split = base.split(\"?\"),\n    basePathname = _base$split[0];\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n    pathBase = _path$split[0],\n    _path$split$ = _path$split[1],\n    query = _path$split$ === undefined ? \"\" : _path$split$;\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n    search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Junk\nvar paramRe = /^:(.+)/;\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return {\n    route: route,\n    score: score,\n    index: index\n  };\n};\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\nvar segmentize = function segmentize(uri) {\n  return uri\n  // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\nvar reservedNames = [\"uri\", \"path\"];\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };","map":{"version":3,"names":["invariant","startsWith","string","search","substr","length","pick","routes","uri","match","default_","_uri$split","split","uriPathname","uriSegments","segmentize","isRootUri","ranked","rankRoutes","i","l","missed","route","default","params","routeSegments","path","max","Math","index","routeSegment","uriSegment","isSplat","param","slice","map","decodeURIComponent","join","undefined","dynamicMatch","paramRe","exec","matchIsNotReserved","reservedNames","indexOf","process","env","NODE_ENV","value","resolve","to","base","_to$split","toPathname","toQuery","_base$split","basePathname","toSegments","baseSegments","addQuery","pathname","concat","allSegments","segments","segment","pop","push","insertParams","_path$split","pathBase","_path$split$","query","constructedPath","_params$location","location","_params$location$sear","searchSplit","validateRedirect","from","filter","isDynamic","fromString","sort","toString","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","test","rankRoute","score","reduce","a","b","replace","_len","arguments","Array","_key","q","shallowCompare","obj1","obj2","obj1Keys","Object","keys","every","key","hasOwnProperty"],"sources":["/Users/ludofederici/neurohackathon/node_modules/@reach/router/es/lib/utils.js"],"sourcesContent":["import invariant from \"invariant\";\n\n////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\nvar match = function match(path, uri) {\n  return pick([{ path: path }], uri);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n      pathBase = _path$split[0],\n      _path$split$ = _path$split[1],\n      query = _path$split$ === undefined ? \"\" : _path$split$;\n\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n      search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Junk\nvar paramRe = /^:(.+)/;\n\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return { route: route, score: score, index: index };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri\n  // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };"],"mappings":"AAAA,OAAOA,SAAS,MAAM,WAAW;;AAEjC;AACA;AACA,IAAIC,UAAU,GAAG,SAASA,UAAUA,CAACC,MAAM,EAAEC,MAAM,EAAE;EACnD,OAAOD,MAAM,CAACE,MAAM,CAAC,CAAC,EAAED,MAAM,CAACE,MAAM,CAAC,KAAKF,MAAM;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,IAAI,GAAG,SAASA,IAAIA,CAACC,MAAM,EAAEC,GAAG,EAAE;EACpC,IAAIC,KAAK,GAAG,KAAK,CAAC;EAClB,IAAIC,QAAQ,GAAG,KAAK,CAAC;EAErB,IAAIC,UAAU,GAAGH,GAAG,CAACI,KAAK,CAAC,GAAG,CAAC;IAC3BC,WAAW,GAAGF,UAAU,CAAC,CAAC,CAAC;EAE/B,IAAIG,WAAW,GAAGC,UAAU,CAACF,WAAW,CAAC;EACzC,IAAIG,SAAS,GAAGF,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE;EACrC,IAAIG,MAAM,GAAGC,UAAU,CAACX,MAAM,CAAC;EAE/B,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,MAAM,CAACZ,MAAM,EAAEc,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAC7C,IAAIE,MAAM,GAAG,KAAK;IAClB,IAAIC,KAAK,GAAGL,MAAM,CAACE,CAAC,CAAC,CAACG,KAAK;IAE3B,IAAIA,KAAK,CAACC,OAAO,EAAE;MACjBb,QAAQ,GAAG;QACTY,KAAK,EAAEA,KAAK;QACZE,MAAM,EAAE,CAAC,CAAC;QACVhB,GAAG,EAAEA;MACP,CAAC;MACD;IACF;IAEA,IAAIiB,aAAa,GAAGV,UAAU,CAACO,KAAK,CAACI,IAAI,CAAC;IAC1C,IAAIF,MAAM,GAAG,CAAC,CAAC;IACf,IAAIG,GAAG,GAAGC,IAAI,CAACD,GAAG,CAACb,WAAW,CAACT,MAAM,EAAEoB,aAAa,CAACpB,MAAM,CAAC;IAC5D,IAAIwB,KAAK,GAAG,CAAC;IAEb,OAAOA,KAAK,GAAGF,GAAG,EAAEE,KAAK,EAAE,EAAE;MAC3B,IAAIC,YAAY,GAAGL,aAAa,CAACI,KAAK,CAAC;MACvC,IAAIE,UAAU,GAAGjB,WAAW,CAACe,KAAK,CAAC;MAEnC,IAAIG,OAAO,CAACF,YAAY,CAAC,EAAE;QACzB;QACA;QACA;QACA,IAAIG,KAAK,GAAGH,YAAY,CAACI,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG;QACxCV,MAAM,CAACS,KAAK,CAAC,GAAGnB,WAAW,CAACoB,KAAK,CAACL,KAAK,CAAC,CAACM,GAAG,CAACC,kBAAkB,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;QAC1E;MACF;MAEA,IAAIN,UAAU,KAAKO,SAAS,EAAE;QAC5B;QACA;QACA;QACAjB,MAAM,GAAG,IAAI;QACb;MACF;MAEA,IAAIkB,YAAY,GAAGC,OAAO,CAACC,IAAI,CAACX,YAAY,CAAC;MAE7C,IAAIS,YAAY,IAAI,CAACvB,SAAS,EAAE;QAC9B,IAAI0B,kBAAkB,GAAGC,aAAa,CAACC,OAAO,CAACL,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QACtE,CAACG,kBAAkB,GAAGG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG/C,SAAS,CAAC,KAAK,EAAE,6BAA6B,GAAGuC,YAAY,CAAC,CAAC,CAAC,GAAG,+DAA+D,GAAGjB,KAAK,CAACI,IAAI,GAAG,KAAK,CAAC,GAAG1B,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAClP,IAAIgD,KAAK,GAAGZ,kBAAkB,CAACL,UAAU,CAAC;QAC1CP,MAAM,CAACe,YAAY,CAAC,CAAC,CAAC,CAAC,GAAGS,KAAK;MACjC,CAAC,MAAM,IAAIlB,YAAY,KAAKC,UAAU,EAAE;QACtC;QACA;QACA;QACAV,MAAM,GAAG,IAAI;QACb;MACF;IACF;IAEA,IAAI,CAACA,MAAM,EAAE;MACXZ,KAAK,GAAG;QACNa,KAAK,EAAEA,KAAK;QACZE,MAAM,EAAEA,MAAM;QACdhB,GAAG,EAAE,GAAG,GAAGM,WAAW,CAACoB,KAAK,CAAC,CAAC,EAAEL,KAAK,CAAC,CAACQ,IAAI,CAAC,GAAG;MACjD,CAAC;MACD;IACF;EACF;EAEA,OAAO5B,KAAK,IAAIC,QAAQ,IAAI,IAAI;AAClC,CAAC;;AAED;AACA;AACA,IAAID,KAAK,GAAG,SAASA,KAAKA,CAACiB,IAAI,EAAElB,GAAG,EAAE;EACpC,OAAOF,IAAI,CAAC,CAAC;IAAEoB,IAAI,EAAEA;EAAK,CAAC,CAAC,EAAElB,GAAG,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIyC,OAAO,GAAG,SAASA,OAAOA,CAACC,EAAE,EAAEC,IAAI,EAAE;EACvC;EACA,IAAIlD,UAAU,CAACiD,EAAE,EAAE,GAAG,CAAC,EAAE;IACvB,OAAOA,EAAE;EACX;EAEA,IAAIE,SAAS,GAAGF,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;IACzByC,UAAU,GAAGD,SAAS,CAAC,CAAC,CAAC;IACzBE,OAAO,GAAGF,SAAS,CAAC,CAAC,CAAC;EAE1B,IAAIG,WAAW,GAAGJ,IAAI,CAACvC,KAAK,CAAC,GAAG,CAAC;IAC7B4C,YAAY,GAAGD,WAAW,CAAC,CAAC,CAAC;EAEjC,IAAIE,UAAU,GAAG1C,UAAU,CAACsC,UAAU,CAAC;EACvC,IAAIK,YAAY,GAAG3C,UAAU,CAACyC,YAAY,CAAC;;EAE3C;EACA,IAAIC,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACxB,OAAOE,QAAQ,CAACH,YAAY,EAAEF,OAAO,CAAC;EACxC;;EAEA;EACA,IAAI,CAACrD,UAAU,CAACwD,UAAU,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;IACnC,IAAIG,QAAQ,GAAGF,YAAY,CAACG,MAAM,CAACJ,UAAU,CAAC,CAACpB,IAAI,CAAC,GAAG,CAAC;IACxD,OAAOsB,QAAQ,CAAC,CAACH,YAAY,KAAK,GAAG,GAAG,EAAE,GAAG,GAAG,IAAII,QAAQ,EAAEN,OAAO,CAAC;EACxE;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAIQ,WAAW,GAAGJ,YAAY,CAACG,MAAM,CAACJ,UAAU,CAAC;EACjD,IAAIM,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG0C,WAAW,CAACzD,MAAM,EAAEc,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAClD,IAAI6C,OAAO,GAAGF,WAAW,CAAC3C,CAAC,CAAC;IAC5B,IAAI6C,OAAO,KAAK,IAAI,EAAED,QAAQ,CAACE,GAAG,CAAC,CAAC,CAAC,KAAK,IAAID,OAAO,KAAK,GAAG,EAAED,QAAQ,CAACG,IAAI,CAACF,OAAO,CAAC;EACvF;EAEA,OAAOL,QAAQ,CAAC,GAAG,GAAGI,QAAQ,CAAC1B,IAAI,CAAC,GAAG,CAAC,EAAEiB,OAAO,CAAC;AACpD,CAAC;;AAED;AACA;;AAEA,IAAIa,YAAY,GAAG,SAASA,YAAYA,CAACzC,IAAI,EAAEF,MAAM,EAAE;EACrD,IAAI4C,WAAW,GAAG1C,IAAI,CAACd,KAAK,CAAC,GAAG,CAAC;IAC7ByD,QAAQ,GAAGD,WAAW,CAAC,CAAC,CAAC;IACzBE,YAAY,GAAGF,WAAW,CAAC,CAAC,CAAC;IAC7BG,KAAK,GAAGD,YAAY,KAAKhC,SAAS,GAAG,EAAE,GAAGgC,YAAY;EAE1D,IAAIP,QAAQ,GAAGhD,UAAU,CAACsD,QAAQ,CAAC;EACnC,IAAIG,eAAe,GAAG,GAAG,GAAGT,QAAQ,CAAC5B,GAAG,CAAC,UAAU6B,OAAO,EAAE;IAC1D,IAAIvD,KAAK,GAAG+B,OAAO,CAACC,IAAI,CAACuB,OAAO,CAAC;IACjC,OAAOvD,KAAK,GAAGe,MAAM,CAACf,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGuD,OAAO;EAC3C,CAAC,CAAC,CAAC3B,IAAI,CAAC,GAAG,CAAC;EACZ,IAAIoC,gBAAgB,GAAGjD,MAAM,CAACkD,QAAQ;EACtCD,gBAAgB,GAAGA,gBAAgB,KAAKnC,SAAS,GAAG,CAAC,CAAC,GAAGmC,gBAAgB;EACzE,IAAIE,qBAAqB,GAAGF,gBAAgB,CAACtE,MAAM;IAC/CA,MAAM,GAAGwE,qBAAqB,KAAKrC,SAAS,GAAG,EAAE,GAAGqC,qBAAqB;EAE7E,IAAIC,WAAW,GAAGzE,MAAM,CAACS,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAC5C4D,eAAe,GAAGb,QAAQ,CAACa,eAAe,EAAED,KAAK,EAAEK,WAAW,CAAC;EAC/D,OAAOJ,eAAe;AACxB,CAAC;AAED,IAAIK,gBAAgB,GAAG,SAASA,gBAAgBA,CAACC,IAAI,EAAE5B,EAAE,EAAE;EACzD,IAAI6B,MAAM,GAAG,SAASA,MAAMA,CAACf,OAAO,EAAE;IACpC,OAAOgB,SAAS,CAAChB,OAAO,CAAC;EAC3B,CAAC;EACD,IAAIiB,UAAU,GAAGlE,UAAU,CAAC+D,IAAI,CAAC,CAACC,MAAM,CAACA,MAAM,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC7C,IAAI,CAAC,GAAG,CAAC;EACjE,IAAI8C,QAAQ,GAAGpE,UAAU,CAACmC,EAAE,CAAC,CAAC6B,MAAM,CAACA,MAAM,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC7C,IAAI,CAAC,GAAG,CAAC;EAC7D,OAAO4C,UAAU,KAAKE,QAAQ;AAChC,CAAC;;AAED;AACA;AACA,IAAI3C,OAAO,GAAG,QAAQ;AAEtB,IAAI4C,cAAc,GAAG,CAAC;AACtB,IAAIC,aAAa,GAAG,CAAC;AACrB,IAAIC,cAAc,GAAG,CAAC;AACtB,IAAIC,aAAa,GAAG,CAAC;AACrB,IAAIC,WAAW,GAAG,CAAC;AAEnB,IAAIC,aAAa,GAAG,SAASA,aAAaA,CAACzB,OAAO,EAAE;EAClD,OAAOA,OAAO,KAAK,EAAE;AACvB,CAAC;AACD,IAAIgB,SAAS,GAAG,SAASA,SAASA,CAAChB,OAAO,EAAE;EAC1C,OAAOxB,OAAO,CAACkD,IAAI,CAAC1B,OAAO,CAAC;AAC9B,CAAC;AACD,IAAIhC,OAAO,GAAG,SAASA,OAAOA,CAACgC,OAAO,EAAE;EACtC,OAAOA,OAAO,IAAIA,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG;AACtC,CAAC;AAED,IAAI2B,SAAS,GAAG,SAASA,SAASA,CAACrE,KAAK,EAAEO,KAAK,EAAE;EAC/C,IAAI+D,KAAK,GAAGtE,KAAK,CAACC,OAAO,GAAG,CAAC,GAAGR,UAAU,CAACO,KAAK,CAACI,IAAI,CAAC,CAACmE,MAAM,CAAC,UAAUD,KAAK,EAAE5B,OAAO,EAAE;IACtF4B,KAAK,IAAIR,cAAc;IACvB,IAAIK,aAAa,CAACzB,OAAO,CAAC,EAAE4B,KAAK,IAAIJ,WAAW,CAAC,KAAK,IAAIR,SAAS,CAAChB,OAAO,CAAC,EAAE4B,KAAK,IAAIN,cAAc,CAAC,KAAK,IAAItD,OAAO,CAACgC,OAAO,CAAC,EAAE4B,KAAK,IAAIR,cAAc,GAAGG,aAAa,CAAC,KAAKK,KAAK,IAAIP,aAAa;IACpM,OAAOO,KAAK;EACd,CAAC,EAAE,CAAC,CAAC;EACL,OAAO;IAAEtE,KAAK,EAAEA,KAAK;IAAEsE,KAAK,EAAEA,KAAK;IAAE/D,KAAK,EAAEA;EAAM,CAAC;AACrD,CAAC;AAED,IAAIX,UAAU,GAAG,SAASA,UAAUA,CAACX,MAAM,EAAE;EAC3C,OAAOA,MAAM,CAAC4B,GAAG,CAACwD,SAAS,CAAC,CAACT,IAAI,CAAC,UAAUY,CAAC,EAAEC,CAAC,EAAE;IAChD,OAAOD,CAAC,CAACF,KAAK,GAAGG,CAAC,CAACH,KAAK,GAAG,CAAC,GAAGE,CAAC,CAACF,KAAK,GAAGG,CAAC,CAACH,KAAK,GAAG,CAAC,CAAC,GAAGE,CAAC,CAACjE,KAAK,GAAGkE,CAAC,CAAClE,KAAK;EAC3E,CAAC,CAAC;AACJ,CAAC;AAED,IAAId,UAAU,GAAG,SAASA,UAAUA,CAACP,GAAG,EAAE;EACxC,OAAOA;EACP;EAAA,CACCwF,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAACpF,KAAK,CAAC,GAAG,CAAC;AACzC,CAAC;AAED,IAAI+C,QAAQ,GAAG,SAASA,QAAQA,CAACC,QAAQ,EAAE;EACzC,KAAK,IAAIqC,IAAI,GAAGC,SAAS,CAAC7F,MAAM,EAAEkE,KAAK,GAAG4B,KAAK,CAACF,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,IAAI,EAAEG,IAAI,EAAE,EAAE;IACvG7B,KAAK,CAAC6B,IAAI,GAAG,CAAC,CAAC,GAAGF,SAAS,CAACE,IAAI,CAAC;EACnC;EAEA7B,KAAK,GAAGA,KAAK,CAACQ,MAAM,CAAC,UAAUsB,CAAC,EAAE;IAChC,OAAOA,CAAC,IAAIA,CAAC,CAAChG,MAAM,GAAG,CAAC;EAC1B,CAAC,CAAC;EACF,OAAOuD,QAAQ,IAAIW,KAAK,IAAIA,KAAK,CAAClE,MAAM,GAAG,CAAC,GAAG,GAAG,GAAGkE,KAAK,CAAClC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;AAC5E,CAAC;AAED,IAAIM,aAAa,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA,IAAI2D,cAAc,GAAG,SAASA,cAAcA,CAACC,IAAI,EAAEC,IAAI,EAAE;EACvD,IAAIC,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAACJ,IAAI,CAAC;EAChC,OAAOE,QAAQ,CAACpG,MAAM,KAAKqG,MAAM,CAACC,IAAI,CAACH,IAAI,CAAC,CAACnG,MAAM,IAAIoG,QAAQ,CAACG,KAAK,CAAC,UAAUC,GAAG,EAAE;IACnF,OAAOL,IAAI,CAACM,cAAc,CAACD,GAAG,CAAC,IAAIN,IAAI,CAACM,GAAG,CAAC,KAAKL,IAAI,CAACK,GAAG,CAAC;EAC5D,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,SAAS5G,UAAU,EAAEK,IAAI,EAAEG,KAAK,EAAEwC,OAAO,EAAEkB,YAAY,EAAEU,gBAAgB,EAAEyB,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module"}