import { Observable, throwError, empty } from "rxjs";
import { switchMap } from "rxjs/operators";
import { whileOnline } from "./whileOnline";
import { validate, isNotionMetric } from "./subscription";
/**
 * @internal
 */
export function getMetric(dependencies, subscription) {
    const { options, api, onDeviceChange, isLocalMode, socketUrl, status } = dependencies;
    const { metric, labels, atomic } = subscription;
    const metricError = validate(metric, labels, options);
    if (metricError) {
        return throwError(metricError);
    }
    const subscribeTo = (serverType) => new Observable((observer) => {
        const subscriptions = atomic
            ? [
                api.metrics.subscribe({
                    metric: metric,
                    labels: labels,
                    atomic: atomic,
                    serverType: serverType
                })
            ]
            : labels.map((label) => {
                return api.metrics.subscribe({
                    metric: metric,
                    labels: [label],
                    atomic: atomic,
                    serverType: serverType
                });
            });
        const subscriptionWithListeners = subscriptions.map((subscription) => ({
            subscription,
            listener: api.metrics.on(subscription, (...data) => {
                observer.next(...data);
            })
        }));
        return () => {
            subscriptionWithListeners.forEach(({ subscription, listener }) => {
                api.metrics.unsubscribe(subscription, listener);
            });
        };
    });
    return onDeviceChange().pipe(switchMap((device) => {
        if (!device) {
            return empty();
        }
        const { deviceId } = device;
        return isLocalMode().pipe(switchMap((isLocalMode) => {
            if (isLocalMode && isNotionMetric(metric)) {
                return socketUrl().pipe(switchMap((socketUrl) => api.setWebsocket(socketUrl, deviceId)), switchMap(() => subscribeTo(api.localServerType)));
            }
            api.unsetWebsocket();
            return subscribeTo(api.defaultServerType);
        }));
    }), whileOnline({
        status$: status(),
        allowWhileOnSleepMode: false
    }));
}
