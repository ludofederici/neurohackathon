import { Observable } from "rxjs";
import { ApiClient, createUser } from "./api/index";
import { NotionOptions } from "./types/options";
import { Training } from "./types/training";
import { Credentials } from "./types/credentials";
import { Settings } from "./types/settings";
import { SignalQuality } from "./types/signalQuality";
import { Kinesis } from "./types/kinesis";
import { Calm } from "./types/calm";
import { Focus } from "./types/focus";
import { BrainwavesLabel, Epoch, PowerByBand, PSD } from "./types/brainwaves";
import { Accelerometer } from "./types/accelerometer";
import { DeviceInfo } from "./types/deviceInfo";
import { DeviceStatus } from "./types/status";
import { Action } from "./types/actions";
import { HapticEffects } from "./types/hapticEffects";
import { OAuthConfig, OAuthQuery, OAuthQueryResult, OAuthRemoveResponse } from "./types/oauth";
import { Experiment } from "./types/experiment";
/**
 * Example
 * ```typescript
 * import { Notion } from "@neurosity/notion";
 *
 * const notion = new Notion();
 * ```
 */
export declare class Notion {
    /**
     * @hidden
     */
    protected options: NotionOptions;
    /**
     * @hidden
     */
    protected api: ApiClient;
    /**
     *
     * @hidden
     */
    static credentialWithLink: Function;
    /**
     *
     * @hidden
     */
    static createUser: typeof createUser;
    /**
     *
     * @hidden
     */
    static SERVER_TIMESTAMP: Object;
    /**
     * Creates new instance of Notion
     *
     * ```typescript
     * const notion = new Notion();
     * ```
  
     * @param options
     */
    constructor(options?: NotionOptions);
    /**
     *
     * @hidden
     */
    private _getMetricDependencies;
    /**
     * Starts user session
     *
     * ```typescript
     * await notion.login({
     *   email: "...",
     *   password: "..."
     * });
     * ```
     *
     * @param credentials
     */
    login(credentials: Credentials): Promise<void>;
    /**
     * Ends user session
     *
     * ```typescript
     * await notion.logout();
     * // session has ended
     * ```
     *
     */
    logout(): Promise<void>;
    /**
     * Subscribe to auth state changes
     *
     * Streams the state of the auth session. If user has logged in, the user object will be set. When logged out, the user object will be null.
     *
     * ```typescript
     * notion.onAuthStateChanged().subscribe((user) => {
     *   console.log(user);
     * });
     * ```
     */
    onAuthStateChanged(): Observable<any>;
    /**
     * Get user devices
     *
     * Returns a list of devices claimed by the user authenticated.
     *
     * ```typescript
     * const devices = await notion.getDevices();
     * console.log(devices);
     * ```
     */
    getDevices(): Promise<DeviceInfo[]>;
    /**
     * Select Device
     *
     * Rarely necessary, but useful when the user owns multiple devices.
     *
     * A common use case for manually selecting a device is when you wish to build a device dropdown a user can select from, instead of collecting the Device Id from the user ahead of time.
     *
     * The 3 steps to manually selecting a device are:
     *
     * - Set `autoSelectDevice` to false when instantiating `Notion`.
     * - Authenticate with your Neurosity account to access your devices by calling the `notion.login(...)` function.
     * - Call the `notion.selectDevice(...)` function with a device selector function.
     *
     * ```typescript
     * const devices = await notion.selectDevice((devices) =>
     *   devices.find((device) => device.deviceNickname === "Notion-A1B")
     * );
     *
     * console.log(devices);
     * ```
     *
     * > If you own multiple devices, and don't pass `autoSelectDevice`, then the first device on the list will be automatically selected.
     *
     * For more info, check out the "Device Selection" guide.
     */
    selectDevice(deviceSelector: (devices: DeviceInfo[]) => DeviceInfo): Promise<DeviceInfo>;
    /**
     * Get selected device
     *
     * ```typescript
     * const selectedDevice = await notion.getSelectedDevice();
     * console.log(selectedDevice);
     * ```
     */
    getSelectedDevice(): Promise<DeviceInfo>;
    /**
     * ```typescript
     * const info = await notion.getInfo();
     * ```
     */
    getInfo(): Promise<DeviceInfo>;
    /**
     * Observes Local Mode changes
     *
     * ```typescript
     * notion.isLocalMode().subscribe(isLocalMode => {
     *  console.log(isLocalMode);
     * });
     * ```
     */
    isLocalMode(): Observable<boolean>;
    /**
     * Observes selected device
     *
     * ```typescript
     * notion.onDeviceChange().subscribe(device => {
     *  console.log(device);
     * });
     * ```
     */
    onDeviceChange(): Observable<DeviceInfo>;
    /**
     * Enables/disables local mode
     *
     * With local mode, device metrics like brainwaves, calm, focus, etc will stream
     * via your local WiFi network and not the default cloud server.
     *
     * Local Mode is disabled by default, to enable it:
     *
     * ```typescript
     * await notion.enableLocalMode(true);
     * ```
     *
     * To disable it:
     *
     * ```typescript
     * await notion.enableLocalMode(false);
     * ```
     *
     * Keep in mind:
     *  - Activity Logging will <em>not work</em> while this setting is enabled.
     *  - Your Notion must be connected to the same WiFi network as this device to establish communication.
     *  - An internet connection is still needed to authenticate, get device status and add metric subscriptions.
     *  - This setting is not global and needs to be set for every Notion app you wish to affect.
     */
    enableLocalMode(shouldEnable: boolean): Promise<boolean>;
    /**
     * Ends database connection
     *
     * ```typescript
     * await notion.disconnect();
     * ```
     */
    disconnect(): Promise<void>;
    /**
     * Injects an EEG marker to data stream
     *
     * ```typescript
     * notion.addMarker("eyes-closed");
     *
     * // later...
     *
     * notion.addMarker("eyes-open");
     * ```
     *
     * @param label Name the label to inject
     */
    addMarker(label: string): Promise<Action>;
    /**
     * Queue haptic motor commands
     *
     * To queue haptic P7 only,
     * ```typescript
     * await notion.haptics({
     *   P7: ["tripleClick100"]
     * });
     * ```
     *
     * To queue both motors at the same time
     * ```typescript
     * await notion.haptics({
     *   P7: [notion.getHapticEffects().strongClick100],
     *   P8: [notion.getHapticEffects().strongClick100]
     * });
     * ```
     *
     * You can queue different commands to the motors too
     * ```typescript
     * const effects = notion.getHapticEffects();
     * await notion.haptics({
     *   P7: [effects.transitionRampUpLongSmooth1_0_to_100,
     *         effects.transitionRampDownLongSmooth1_100_to_0],
     *   P8: [effects.strongClick100]
     * });
     * ```
     *
     * @param effects Effects to queue. The key of the object passed should be the location of the motor
     *  to queue. Each key can be an array of up to 7 commands. There is no haptic support on model
     *  version 1, Notion DK1. The Haptic motor's location is positioned in reference to the 10-10 EEG
     *  system used to label the channels of the Crown's EEG sensors. Notion 2 and Crown have haptics
     *  at P7 and P8. A list of haptic commands can be found on ./utils/hapticCodes.ts - there
     *  are about 127 of them!
     */
    haptics(effects: any): Promise<any>;
    /**
     * ```typescript
     * const effects = notion.getHapticEffects();
     * ```
     */
    getHapticEffects(): HapticEffects;
    /**
     * Observes accelerometer data
     * Supported by Notion 2 and the Crown.
     *
     * ```typescript
     * notion.accelerometer().subscribe(accelerometer => {
     *   console.log(accelerometer);
     * });
     *
     * // { acceleration: ..., inclination: ..., orientation: ..., pitch: ..., roll: ..., x: ..., y: ..., z: ... }
     * ```
     *
     * @returns Observable of accelerometer metric events
     */
    accelerometer(): Observable<Accelerometer>;
    /**
     * The `raw` brainwaves parameter emits epochs of 16 samples for Crown and 25 for Notion 1 and 2.
     *
     * Example
     * ```typescript
     * notion.brainwaves("raw").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Raw Unfiltered - The `rawUnfiltered` brainwaves parameter emits epochs of 16 samples for Crown and 25 for Notion 1 and 2.
  
     * Example
     * ```typescript
     * notion.brainwaves("rawUnfiltered").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power By Band - The `powerByBand` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. beta) contains an average power value per channel.
     *
     * Example
     * ```typescript
     * notion.brainwaves("powerByBand").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power Spectral Density (PSD) - The `psd` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. alpha) contains the computed FFT (Fast Fourier transform) value per channel (see the `psd` property), as well as the frequency ranges (see the `freqs` property).
     *
     * Example
     * ```typescript
     * notion.brainwaves("psd").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of brainwaves metric events
     */
    brainwaves(label: BrainwavesLabel, ...otherLabels: BrainwavesLabel[]): Observable<Epoch | PowerByBand | PSD>;
    /**
     * Example
     * ```typescript
     * notion.calm().subscribe(calm => {
     *   console.log(calm.probability);
     * });
     *
     * // 0.45
     * // 0.47
     * // 0.53
     * // 0.51
     * // ...
     * ```
     *
     * @returns Observable of calm events - awareness/calm alias
     */
    calm(): Observable<Calm>;
    /**
     * Observes signal quality data where each property is the name
     * of the channel and the value includes the standard deviation and
     * a status set by the device
     *
     * ```typescript
     * notion.signalQuality().subscribe(signalQuality => {
     *   console.log(signalQuality);
     * });
     *
     * // { FC6: { standardDeviation: 3.5, status: "good" }, C3: {...}, ... }
     * ```
     *
     * @returns Observable of signalQuality metric events
     */
    signalQuality(): Observable<SignalQuality>;
    /**
     * Observes last state of `settings` and all subsequent `settings` changes
     *
     * ```typescript
     * notion.settings().subscribe(settings => {
     *   console.log(settings.lsl);
     * });
     *
     * // true
     * // ...
     * ```
     *
     * @returns Observable of `settings` metric events
     */
    settings(): Observable<Settings>;
    /**
     * Example
     * ```typescript
     * notion.focus().subscribe(focus => {
     *   console.log(focus.probability);
     * });
     *
     * // 0.56
     * // 0.46
     * // 0.31
     * // 0.39
     * // ...
     * ```
     *
     * @returns Observable of focus events - awareness/focus alias
     */
    focus(): Observable<Focus>;
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of kinesis metric events
     */
    kinesis(label: string, ...otherLabels: string[]): Observable<Kinesis>;
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of predictions metric events
     */
    predictions(label: string, ...otherLabels: string[]): Observable<any>;
    /**
     * Observes last state of `status` and all subsequent `status` changes
     *
     * ```typescript
     * notion.status().subscribe(status => {
     *   console.log(status.state);
     * });
     *
     * // "online"
     * // ...
     * ```
     *
     * @returns Observable of `status` metric events
     */
    status(): Observable<DeviceStatus>;
    /**
     *
     * ```typescript
     * notion.training.record({
     *   metric: "kinesis",
     *   label: "push"
     * });
     *
     * notion.training.stop({
     *   metric: "kinesis",
     *   label: "push"
     * });
     * ```
     *
     * @returns Training methods
     */
    get training(): Training;
    /**
     * Create OAuth URL
     * 💡 OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Creates client-specific OAuth URL. This is the first step of the OAuth workflow. Use this function to create a URL you can use to redirect users to the Neurosity sign-in page.
     * 💡 This function is designed to only run on the server side for security reasons, as it requires your client secret.
     *
     * ```typescript
     * const { Notion } = require("@neurosity/notion");
     *
     * const notion = new Notion({
     *   autoSelectDevice: false
     * });
     *
     * exports.handler = async function (event) {
     *   return notion
     *     .createOAuthURL({
     *       clientId: process.env.NEUROSITY_OAUTH_CLIENT_ID,
     *       clientSecret: process.env.NEUROSITY_OAUTH_CLIENT_SECRET,
     *       redirectUri: process.env.NEUROSITY_OAUTH_CLIENT_REDIRECT_URI,
     *       responseType: "token",
     *       state: Math.random().toString().split(".")[1],
     *       scope: [
     *         "read:devices-info",
     *         "read:devices-status",
     *         "read:signal-quality",
     *         "read:brainwaves"
     *       ]
     *     })
     *     .then((url) => ({
     *       statusCode: 200,
     *       body: JSON.stringify({ url })
     *     }))
     *     .catch((error) => ({
     *       statusCode: 400,
     *       body: JSON.stringify(error.response.data)
     *     }));
     * };
     * ```
     * @returns custom token
     */
    createOAuthURL(config: OAuthConfig): Promise<string>;
    /**
     * Get OAuth Token
     * 💡 OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Gets client-specific OAuth token for a given userId.
     *
     * 💡 This function is designed to only run on the server side for security reasons, as it requires your client secret.
     * Here's an example of a cloud function that receives a `userId` via query params and loads the client id and client secret securely via environment variables.
     *
     *
     * ```typescript
     * const { Notion } = require("@neurosity/notion");
     *
     * const notion = new Notion({
     *   autoSelectDevice: false
     * });
     *
     * exports.handler = async function (event) {
     *   const userId = event.queryStringParameters?.userId;
     *
     *   return notion
     *     .getOAuthToken({
     *       clientId: process.env.NEUROSITY_OAUTH_CLIENT_ID,
     *       clientSecret: process.env.NEUROSITY_OAUTH_CLIENT_SECRET,
     *       userId
     *     })
     *     .then((token) => ({
     *       statusCode: 200,
     *       body: JSON.stringify(token)
     *     }))
     *     .catch((error) => ({
     *       statusCode: 200,
     *       body: JSON.stringify(error.response.data)
     *     }));
     * };
     * ```
     * @returns custom token
     */
    getOAuthToken(query: OAuthQuery): Promise<OAuthQueryResult>;
    /**
     * Remove OAuth Access
     * 💡 OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Removes client-specific OAuth token for a given userId. Requires SDK to be signed in with OAuth custom token.
     *
     * ```typescript
     * await notion.removeOAuthAccess().catch((error) => {
     *   // handle error here...
     * });
     * ```
     * @returns custom token
     */
    removeOAuthAccess(): Promise<OAuthRemoveResponse>;
    /**
     * Observes and returns a list of all Kinesis `experiments` and all subsequent experiment changes.
     * Here's an example of how to get a list of all Kinesis labels that have been trained:
     *
     * ```typescript
     *
     * const getUniqueLabels = (experiments) => {
     *   const labels = experiments.flatMap((experiment) => experiment.labels);
     *   // only return unique labels
     *   return [...new Set(labels)];
     * }
     *
     * notion.onUserExperiments().subscribe((experiments) => {
     *   console.log(experiments);
     *   console.log("labels", getUniqueLabels(experiments));
     * });
     *
     * // [{ id: '...', deviceId: '...', labels: [ 'drop' ], name: 'Lightgray cheetah', timestamp: 1577908381552, totalTrials: 16, userId: '...' }]
     * // ["drop", "lift", "push"]
     * ```
     *
     * @returns Observable of `experiments` events
     */
    onUserExperiments(): Observable<Experiment[]>;
    /**
     * Deletes a specific experiment provided an experiment ID
     *
     * ```typescript
     * await notion.deleteUserExperiment(experiment.id);
     * ```
     *
     * @param experimentId The ID of the Experiment
     * @returns void
     */
    deleteUserExperiment(experimentId: string): Promise<void>;
}
