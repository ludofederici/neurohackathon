"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const index_1 = require("./api/index");
const subscription_1 = require("./utils/subscription");
const errors = __importStar(require("./utils/errors"));
const platform = __importStar(require("./utils/platform"));
const hapticEffects = __importStar(require("./utils/hapticEffects"));
const oauth_1 = require("./utils/oauth");
const createOAuthURL_1 = require("./api/https/createOAuthURL");
const getOAuthToken_1 = require("./api/https/getOAuthToken");
const is_node_1 = require("./utils/is-node");
const metrics_1 = require("./utils/metrics");
const defaultOptions = {
    timesync: false,
    autoSelectDevice: true,
    emulator: false,
    emulatorHost: "localhost",
    emulatorAuthPort: 9099,
    emulatorDatabasePort: 9000,
    emulatorFunctionsPort: 5001,
    emulatorFirestorePort: 8080,
    emulatorOptions: {}
};
/**
 * Example
 * ```typescript
 * import { Notion } from "@neurosity/notion";
 *
 * const notion = new Notion();
 * ```
 */
class Notion {
    /**
     * Creates new instance of Notion
     *
     * ```typescript
     * const notion = new Notion();
     * ```
  
     * @param options
     */
    constructor(options = {}) {
        /**
         * @internal
         */
        this._localModeSubject = new rxjs_1.BehaviorSubject(false);
        this.options = Object.freeze(Object.assign(Object.assign({}, defaultOptions), options));
        this.api = new index_1.ApiClient(this.options);
    }
    /**
     *
     * @hidden
     */
    _getMetricDependencies() {
        return {
            options: this.options,
            api: this.api,
            onDeviceChange: this.onDeviceChange.bind(this),
            isLocalMode: this.isLocalMode.bind(this),
            socketUrl: this.socketUrl.bind(this),
            status: this.status.bind(this)
        };
    }
    /**
     * Starts user session
     *
     * ```typescript
     * await notion.login({
     *   email: "...",
     *   password: "..."
     * });
     * ```
     *
     * @param credentials
     */
    login(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.login(credentials);
        });
    }
    /**
     * Ends user session
     *
     * ```typescript
     * await notion.logout();
     * // session has ended
     * ```
     *
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.logout();
        });
    }
    /**
     * @internal
     * Not user facing.
     */
    __getApp() {
        return this.api.__getApp();
    }
    /**
     * Subscribe to auth state changes
     *
     * Streams the state of the auth session. If user has logged in, the user object will be set. When logged out, the user object will be null.
     *
     * ```typescript
     * notion.onAuthStateChanged().subscribe((user) => {
     *   console.log(user);
     * });
     * ```
     */
    onAuthStateChanged() {
        return this.api.onAuthStateChanged();
    }
    /**
     * @internal
     * Not user facing yet
     */
    addDevice(deviceId) {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "addDevice");
        if (hasOAuthError) {
            return Promise.reject(OAuthError);
        }
        return this.api.addDevice(deviceId);
    }
    /**
     * @internal
     * Not user facing yet
     */
    removeDevice(deviceId) {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "removeDevice");
        if (hasOAuthError) {
            return Promise.reject(OAuthError);
        }
        return this.api.removeDevice(deviceId);
    }
    /**
     * @internal
     * Not user facing yet
     */
    transferDevice(options) {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "transferDevice");
        if (hasOAuthError) {
            return Promise.reject(OAuthError);
        }
        return this.api.transferDevice(options);
    }
    /**
     * @internal
     * Not user facing yet
     */
    onUserDevicesChange() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "onUserDevicesChange");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return this.api.onUserDevicesChange();
    }
    /**
     * @internal
     * Not user facing yet
     */
    onUserClaimsChange() {
        return this.api.onUserClaimsChange();
    }
    /**
     * Get user devices
     *
     * Returns a list of devices claimed by the user authenticated.
     *
     * ```typescript
     * const devices = await notion.getDevices();
     * console.log(devices);
     * ```
     */
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.getDevices();
        });
    }
    /**
     * Select Device
     *
     * Rarely necessary, but useful when the user owns multiple devices.
     *
     * A common use case for manually selecting a device is when you wish to build a device dropdown a user can select from, instead of collecting the Device Id from the user ahead of time.
     *
     * The 3 steps to manually selecting a device are:
     *
     * - Set `autoSelectDevice` to false when instantiating `Notion`.
     * - Authenticate with your Neurosity account to access your devices by calling the `notion.login(...)` function.
     * - Call the `notion.selectDevice(...)` function with a device selector function.
     *
     * ```typescript
     * const devices = await notion.selectDevice((devices) =>
     *   devices.find((device) => device.deviceNickname === "Notion-A1B")
     * );
     *
     * console.log(devices);
     * ```
     *
     * > If you own multiple devices, and don't pass `autoSelectDevice`, then the first device on the list will be automatically selected.
     *
     * For more info, check out the "Device Selection" guide.
     */
    selectDevice(deviceSelector) {
        return __awaiter(this, void 0, void 0, function* () {
            const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "selectDevice");
            if (hasOAuthError) {
                return Promise.reject(OAuthError);
            }
            return yield this.api.selectDevice(deviceSelector);
        });
    }
    /**
     * Get selected device
     *
     * ```typescript
     * const selectedDevice = await notion.getSelectedDevice();
     * console.log(selectedDevice);
     * ```
     */
    getSelectedDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "getSelectedDevice");
            if (hasOAuthError) {
                return Promise.reject(OAuthError);
            }
            return yield this.api.getSelectedDevice();
        });
    }
    /**
     * ```typescript
     * const info = await notion.getInfo();
     * ```
     */
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.api.didSelectDevice()) {
                return Promise.reject(errors.mustSelectDevice);
            }
            const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "getInfo");
            if (hasOAuthError) {
                return Promise.reject(OAuthError);
            }
            return yield this.api.getInfo();
        });
    }
    /**
     * Observes Local Mode changes
     *
     * ```typescript
     * notion.isLocalMode().subscribe(isLocalMode => {
     *  console.log(isLocalMode);
     * });
     * ```
     */
    isLocalMode() {
        return this._localModeSubject.asObservable().pipe(operators_1.share());
    }
    /**
     * Observes selected device
     *
     * ```typescript
     * notion.onDeviceChange().subscribe(device => {
     *  console.log(device);
     * });
     * ```
     */
    onDeviceChange() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "onDeviceChange");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return this.api.onDeviceChange();
    }
    /**
     * Enables/disables local mode
     *
     * With local mode, device metrics like brainwaves, calm, focus, etc will stream
     * via your local WiFi network and not the default cloud server.
     *
     * Local Mode is disabled by default, to enable it:
     *
     * ```typescript
     * await notion.enableLocalMode(true);
     * ```
     *
     * To disable it:
     *
     * ```typescript
     * await notion.enableLocalMode(false);
     * ```
     *
     * Keep in mind:
     *  - Activity Logging will <em>not work</em> while this setting is enabled.
     *  - Your Notion must be connected to the same WiFi network as this device to establish communication.
     *  - An internet connection is still needed to authenticate, get device status and add metric subscriptions.
     *  - This setting is not global and needs to be set for every Notion app you wish to affect.
     */
    enableLocalMode(shouldEnable) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof shouldEnable !== "boolean") {
                return Promise.reject(new TypeError("enableLocalMode can only accept a boolean"));
            }
            if (!shouldEnable) {
                this._localModeSubject.next(shouldEnable);
                return shouldEnable;
            }
            const [localModeSupported, error] = yield this.api
                .onceNamespace("context/socketUrl")
                .then((socketUrl) => {
                if (!socketUrl) {
                    const error = `${errors.prefix}Your device's OS does not support localMode. Try updating to the latest OS.`;
                    return [false, new Error(error)];
                }
                return [true, null];
            })
                .catch((error) => [false, error]);
            if (!localModeSupported) {
                return Promise.reject(error);
            }
            this._localModeSubject.next(shouldEnable);
            return shouldEnable;
        });
    }
    /**
     * Ends database connection
     *
     * ```typescript
     * await notion.disconnect();
     * ```
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.disconnect();
        });
    }
    /**
     * @internal
     * Not user facing
     */
    socketUrl() {
        const { onDeviceSocketUrl } = this.options;
        if (onDeviceSocketUrl) {
            return rxjs_1.of(onDeviceSocketUrl);
        }
        return this.api.observeNamespace("context/socketUrl");
    }
    /**
     * @internal
     * Not user facing
     */
    dispatchAction(action) {
        if (!this.api.didSelectDevice()) {
            return Promise.reject(errors.mustSelectDevice);
        }
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForAction(this.api.userClaims, action);
        if (hasOAuthError) {
            return Promise.reject(OAuthError);
        }
        return this.api.actions.dispatch(action);
    }
    /**
     * Injects an EEG marker to data stream
     *
     * ```typescript
     * notion.addMarker("eyes-closed");
     *
     * // later...
     *
     * notion.addMarker("eyes-open");
     * ```
     *
     * @param label Name the label to inject
     */
    addMarker(label) {
        if (!this.api.didSelectDevice()) {
            throw errors.mustSelectDevice;
        }
        if (!label) {
            throw new Error(`${errors.prefix}A label is required for addMarker`);
        }
        return this.dispatchAction({
            command: "marker",
            action: "add",
            message: {
                label,
                timestamp: this.api.timestamp
            }
        });
    }
    /**
     * Queue haptic motor commands
     *
     * To queue haptic P7 only,
     * ```typescript
     * await notion.haptics({
     *   P7: ["tripleClick100"]
     * });
     * ```
     *
     * To queue both motors at the same time
     * ```typescript
     * await notion.haptics({
     *   P7: [notion.getHapticEffects().strongClick100],
     *   P8: [notion.getHapticEffects().strongClick100]
     * });
     * ```
     *
     * You can queue different commands to the motors too
     * ```typescript
     * const effects = notion.getHapticEffects();
     * await notion.haptics({
     *   P7: [effects.transitionRampUpLongSmooth1_0_to_100,
     *         effects.transitionRampDownLongSmooth1_100_to_0],
     *   P8: [effects.strongClick100]
     * });
     * ```
     *
     * @param effects Effects to queue. The key of the object passed should be the location of the motor
     *  to queue. Each key can be an array of up to 7 commands. There is no haptic support on model
     *  version 1, Notion DK1. The Haptic motor's location is positioned in reference to the 10-10 EEG
     *  system used to label the channels of the Crown's EEG sensors. Notion 2 and Crown have haptics
     *  at P7 and P8. A list of haptic commands can be found on ./utils/hapticCodes.ts - there
     *  are about 127 of them!
     */
    haptics(effects) {
        return __awaiter(this, void 0, void 0, function* () {
            const metric = "haptics";
            if (!this.api.didSelectDevice()) {
                return Promise.reject(errors.mustSelectDevice);
            }
            const modelVersion = (yield this.getSelectedDevice()).modelVersion;
            const supportsHaptics = platform.supportsHaptics(modelVersion);
            if (!supportsHaptics) {
                return Promise.reject(errors.metricNotSupportedByModel(metric, modelVersion));
            }
            const newPlatformHapticRequest = platform.getPlatformHapticMotors(modelVersion);
            for (const key in effects) {
                if (!Object.keys(newPlatformHapticRequest).includes(key)) {
                    return Promise.reject(errors.locationNotFound(key, modelVersion));
                }
                const singleMotorEffects = effects[key];
                const maxItems = 7;
                if (singleMotorEffects.length > maxItems) {
                    return Promise.reject(errors.exceededMaxItems(maxItems));
                }
                newPlatformHapticRequest[key] = singleMotorEffects;
            }
            return this.dispatchAction({
                command: metric,
                action: "queue",
                responseRequired: true,
                responseTimeout: 1000,
                message: { effects: newPlatformHapticRequest }
            });
        });
    }
    /**
     * ```typescript
     * const effects = notion.getHapticEffects();
     * ```
     */
    getHapticEffects() {
        return hapticEffects;
    }
    /**
     * Observes accelerometer data
     * Supported by Notion 2 and the Crown.
     *
     * ```typescript
     * notion.accelerometer().subscribe(accelerometer => {
     *   console.log(accelerometer);
     * });
     *
     * // { acceleration: ..., inclination: ..., orientation: ..., pitch: ..., roll: ..., x: ..., y: ..., z: ... }
     * ```
     *
     * @returns Observable of accelerometer metric events
     */
    accelerometer() {
        const metric = "accelerometer";
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, metric);
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return rxjs_1.from(this.getSelectedDevice()).pipe(operators_1.switchMap((selectedDevice) => {
            const modelVersion = (selectedDevice === null || selectedDevice === void 0 ? void 0 : selectedDevice.modelVersion) || platform.MODEL_VERSION_1;
            const supportsAccel = platform.supportsAccel(modelVersion);
            if (!supportsAccel) {
                return rxjs_1.throwError(errors.metricNotSupportedByModel(metric, modelVersion));
            }
            return metrics_1.getMetric(this._getMetricDependencies(), {
                metric,
                labels: subscription_1.getLabels(metric),
                atomic: true
            });
        }));
    }
    /**
     * The `raw` brainwaves parameter emits epochs of 16 samples for Crown and 25 for Notion 1 and 2.
     *
     * Example
     * ```typescript
     * notion.brainwaves("raw").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Raw Unfiltered - The `rawUnfiltered` brainwaves parameter emits epochs of 16 samples for Crown and 25 for Notion 1 and 2.
  
     * Example
     * ```typescript
     * notion.brainwaves("rawUnfiltered").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power By Band - The `powerByBand` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. beta) contains an average power value per channel.
     *
     * Example
     * ```typescript
     * notion.brainwaves("powerByBand").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power Spectral Density (PSD) - The `psd` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. alpha) contains the computed FFT (Fast Fourier transform) value per channel (see the `psd` property), as well as the frequency ranges (see the `freqs` property).
     *
     * Example
     * ```typescript
     * notion.brainwaves("psd").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of brainwaves metric events
     */
    brainwaves(label, ...otherLabels) {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "brainwaves");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric: "brainwaves",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Example
     * ```typescript
     * notion.calm().subscribe(calm => {
     *   console.log(calm.probability);
     * });
     *
     * // 0.45
     * // 0.47
     * // 0.53
     * // 0.51
     * // ...
     * ```
     *
     * @returns Observable of calm events - awareness/calm alias
     */
    calm() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "calm");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric: "awareness",
            labels: ["calm"],
            atomic: false
        });
    }
    /**
     * Observes signal quality data where each property is the name
     * of the channel and the value includes the standard deviation and
     * a status set by the device
     *
     * ```typescript
     * notion.signalQuality().subscribe(signalQuality => {
     *   console.log(signalQuality);
     * });
     *
     * // { FC6: { standardDeviation: 3.5, status: "good" }, C3: {...}, ... }
     * ```
     *
     * @returns Observable of signalQuality metric events
     */
    signalQuality() {
        const metric = "signalQuality";
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, metric);
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric,
            labels: subscription_1.getLabels(metric),
            atomic: true
        });
    }
    /**
     * Observes last state of `settings` and all subsequent `settings` changes
     *
     * ```typescript
     * notion.settings().subscribe(settings => {
     *   console.log(settings.lsl);
     * });
     *
     * // true
     * // ...
     * ```
     *
     * @returns Observable of `settings` metric events
     */
    settings() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "settings");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return this.api.observeNamespace("settings");
    }
    /**
     * Example
     * ```typescript
     * notion.focus().subscribe(focus => {
     *   console.log(focus.probability);
     * });
     *
     * // 0.56
     * // 0.46
     * // 0.31
     * // 0.39
     * // ...
     * ```
     *
     * @returns Observable of focus events - awareness/focus alias
     */
    focus() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "focus");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric: "awareness",
            labels: ["focus"],
            atomic: false
        });
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of kinesis metric events
     */
    kinesis(label, ...otherLabels) {
        const metric = "kinesis";
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, metric);
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric,
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of predictions metric events
     */
    predictions(label, ...otherLabels) {
        const metric = "predictions";
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, metric);
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return metrics_1.getMetric(this._getMetricDependencies(), {
            metric,
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Observes last state of `status` and all subsequent `status` changes
     *
     * ```typescript
     * notion.status().subscribe(status => {
     *   console.log(status.state);
     * });
     *
     * // "online"
     * // ...
     * ```
     *
     * @returns Observable of `status` metric events
     */
    status() {
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "status");
        if (hasOAuthError) {
            return rxjs_1.throwError(OAuthError);
        }
        return this.api.status();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Changes device settings programmatically. These settings can be
     * also changed from the developer console under device settings.
     *
     * Available settings [[ChangeSettings]]
     *
     * Example
     * ```typescript
     * notion.changeSettings({
     *   lsl: true
     * });
     * ```
     */
    changeSettings(settings) {
        if (!this.api.didSelectDevice()) {
            return Promise.reject(errors.mustSelectDevice);
        }
        const [hasOAuthError, OAuthError] = oauth_1.validateOAuthScopeForFunctionName(this.api.userClaims, "changeSettings");
        if (hasOAuthError) {
            return Promise.reject(OAuthError);
        }
        return this.api.changeSettings(settings);
    }
    /**
     *
     * ```typescript
     * notion.training.record({
     *   metric: "kinesis",
     *   label: "push"
     * });
     *
     * notion.training.stop({
     *   metric: "kinesis",
     *   label: "push"
     * });
     * ```
     *
     * @returns Training methods
     */
    get training() {
        return {
            /**
             * Records a training for a metric/label pair
             * @category Training
             */
            record: (training) => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                const userId = this.api.user && "uid" in this.api.user
                    ? this.api.user.uid
                    : null;
                const message = Object.assign(Object.assign({ fit: false, baseline: false, timestamp: this.api.timestamp }, training), { userId });
                this.api.actions.dispatch({
                    command: "training",
                    action: "record",
                    message
                });
            },
            /**
             * Stops the training for a metric/label pair
             * @category Training
             */
            stop: (training) => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                this.api.actions.dispatch({
                    command: "training",
                    action: "stop",
                    message: Object.assign({}, training)
                });
            },
            /**
             * Stops all trainings
             * @category Training
             */
            stopAll: () => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                this.api.actions.dispatch({
                    command: "training",
                    action: "stopAll",
                    message: {}
                });
            }
        };
    }
    /**
     * @internal
     * Proof of Concept for disconnecting db
     */
    goOffline() {
        this.api.goOffline();
    }
    /**
     * @internal
     * Proof of Concept for resuming db connection
     */
    goOnline() {
        this.api.goOnline();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Creates user account and automatically signs in with same credentials
     *
     * @param emailAndPasswordObject
     * @returns user credential
     */
    createAccount(credentials) {
        return this.api.createAccount(credentials);
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Removes all devices from an account and then deletes the account
     */
    deleteAccount() {
        return this.api.deleteAccount();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Creates custom token (JWT) to use to login with `{ customToken }`.
     *
     * @returns custom token
     */
    createCustomToken() {
        return this.api.createCustomToken();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Gets the offset between the device's clock and the client's clock
     * Requires option.timesync to be true
     *
     * @returns timesyncOffset
     */
    getTimesyncOffset() {
        if (!this.options.timesync) {
            console.warn(`getTimesyncOffset() requires options.timesync to be true.`);
        }
        return this.options.timesync ? this.api.getTimesyncOffset() : 0;
    }
    /**
     * Create OAuth URL
     * ðŸ’¡ OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Creates client-specific OAuth URL. This is the first step of the OAuth workflow. Use this function to create a URL you can use to redirect users to the Neurosity sign-in page.
     * ðŸ’¡ This function is designed to only run on the server side for security reasons, as it requires your client secret.
     *
     * ```typescript
     * const { Notion } = require("@neurosity/notion");
     *
     * const notion = new Notion({
     *   autoSelectDevice: false
     * });
     *
     * exports.handler = async function (event) {
     *   return notion
     *     .createOAuthURL({
     *       clientId: process.env.NEUROSITY_OAUTH_CLIENT_ID,
     *       clientSecret: process.env.NEUROSITY_OAUTH_CLIENT_SECRET,
     *       redirectUri: process.env.NEUROSITY_OAUTH_CLIENT_REDIRECT_URI,
     *       responseType: "token",
     *       state: Math.random().toString().split(".")[1],
     *       scope: [
     *         "read:devices-info",
     *         "read:devices-status",
     *         "read:signal-quality",
     *         "read:brainwaves"
     *       ]
     *     })
     *     .then((url) => ({
     *       statusCode: 200,
     *       body: JSON.stringify({ url })
     *     }))
     *     .catch((error) => ({
     *       statusCode: 400,
     *       body: JSON.stringify(error.response.data)
     *     }));
     * };
     * ```
     * @returns custom token
     */
    createOAuthURL(config) {
        if (!is_node_1.isNode) {
            return Promise.reject(new Error(`${errors.prefix}the createOAuthURL method must be used on the server side (node.js) for security reasons.`));
        }
        return createOAuthURL_1.createOAuthURL(config, this.options);
    }
    /**
     * Get OAuth Token
     * ðŸ’¡ OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Gets client-specific OAuth token for a given userId.
     *
     * ðŸ’¡ This function is designed to only run on the server side for security reasons, as it requires your client secret.
     * Here's an example of a cloud function that receives a `userId` via query params and loads the client id and client secret securely via environment variables.
     *
     *
     * ```typescript
     * const { Notion } = require("@neurosity/notion");
     *
     * const notion = new Notion({
     *   autoSelectDevice: false
     * });
     *
     * exports.handler = async function (event) {
     *   const userId = event.queryStringParameters?.userId;
     *
     *   return notion
     *     .getOAuthToken({
     *       clientId: process.env.NEUROSITY_OAUTH_CLIENT_ID,
     *       clientSecret: process.env.NEUROSITY_OAUTH_CLIENT_SECRET,
     *       userId
     *     })
     *     .then((token) => ({
     *       statusCode: 200,
     *       body: JSON.stringify(token)
     *     }))
     *     .catch((error) => ({
     *       statusCode: 200,
     *       body: JSON.stringify(error.response.data)
     *     }));
     * };
     * ```
     * @returns custom token
     */
    getOAuthToken(query) {
        if (!is_node_1.isNode) {
            return Promise.reject(new Error(`${errors.prefix}the getOAuthToken method must be used on the server side (node.js) for security reasons.`));
        }
        return getOAuthToken_1.getOAuthToken(query, this.options);
    }
    /**
     * Remove OAuth Access
     * ðŸ’¡ OAuth requires developers to register their apps with Neurosity
     * [Read full OAuth guide](/docs/oauth)
     *
     * Removes client-specific OAuth token for a given userId. Requires SDK to be signed in with OAuth custom token.
     *
     * ```typescript
     * await notion.removeOAuthAccess().catch((error) => {
     *   // handle error here...
     * });
     * ```
     * @returns custom token
     */
    removeOAuthAccess() {
        return this.api.removeOAuthAccess();
    }
    /**
     * @internal
     * Proof of Concept for Skills - Not user facing yet
     *
     * Accesses a skill by Bundle ID. Additionally, allows to observe
     * and push skill metrics
     *
     * @param bundleId Bundle ID of skill
     * @returns Skill instance
     */
    skill(bundleId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.api.didSelectDevice()) {
                return Promise.reject(errors.mustSelectDevice);
            }
            const skillData = yield this.api.skills.get(bundleId);
            if (skillData === null) {
                return Promise.reject(new Error(`${errors.prefix}Access denied for: ${bundleId}. Make sure the skill is installed.`));
            }
            return {
                metric: (label) => {
                    const metricName = `skill~${skillData.id}~${label}`;
                    const subscription = new rxjs_1.Observable((observer) => {
                        const subscription = this.api.metrics.subscribe({
                            metric: metricName,
                            labels: [label],
                            atomic: true
                        });
                        const listener = this.api.metrics.on(subscription, (...data) => {
                            observer.next(...data);
                        });
                        return () => {
                            this.api.metrics.unsubscribe(subscription, listener);
                        };
                    }).pipe(operators_1.map((metric) => metric[label]));
                    Object.defineProperty(subscription, "next", {
                        value: (metricValue) => {
                            this.api.metrics.next(metricName, {
                                [label]: metricValue
                            });
                        }
                    });
                    return subscription;
                }
            };
        });
    }
    /**
     * Observes and returns a list of all Kinesis `experiments` and all subsequent experiment changes.
     * Here's an example of how to get a list of all Kinesis labels that have been trained:
     *
     * ```typescript
     *
     * const getUniqueLabels = (experiments) => {
     *   const labels = experiments.flatMap((experiment) => experiment.labels);
     *   // only return unique labels
     *   return [...new Set(labels)];
     * }
     *
     * notion.onUserExperiments().subscribe((experiments) => {
     *   console.log(experiments);
     *   console.log("labels", getUniqueLabels(experiments));
     * });
     *
     * // [{ id: '...', deviceId: '...', labels: [ 'drop' ], name: 'Lightgray cheetah', timestamp: 1577908381552, totalTrials: 16, userId: '...' }]
     * // ["drop", "lift", "push"]
     * ```
     *
     * @returns Observable of `experiments` events
     */
    onUserExperiments() {
        return this.api.onUserExperiments();
    }
    /**
     * Deletes a specific experiment provided an experiment ID
     *
     * ```typescript
     * await notion.deleteUserExperiment(experiment.id);
     * ```
     *
     * @param experimentId The ID of the Experiment
     * @returns void
     */
    deleteUserExperiment(experimentId) {
        return this.api.deleteUserExperiment(experimentId);
    }
}
exports.Notion = Notion;
/**
 *
 * @hidden
 */
Notion.credentialWithLink = index_1.credentialWithLink;
/**
 *
 * @hidden
 */
Notion.createUser = index_1.createUser;
/**
 *
 * @hidden
 */
Notion.SERVER_TIMESTAMP = index_1.SERVER_TIMESTAMP;
